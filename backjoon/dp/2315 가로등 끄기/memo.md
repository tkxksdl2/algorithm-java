[2315 가로등 끄기](https://www.acmicpc.net/problem/2315)

---

점화식을 도출하기 상당히 난해한 dp 문제.

문제의 조건을 살펴보면 다음과 같은 몇 가지 사실을 알 수 있다.

1. 로봇은 현재 위치에서 좌, 우로 이동하여 가장 가까운 가로등을 끌 수 있다.
2. 로봇이 새로운 위치로 이동하면 이동거리와 꺼지지 않은 가로등의 비용에 비례해 총비용이 증가한다.

그렇다면 이 문제는 로봇이 현재 위치에서 반복적으로 좌, 우로 이동하는 분기를 갖는 DFS , 완전탐색으로도 생각할 수 있다.

실제로도 그렇게 풀이해보았고 답은 구할 수 있으나 메모리 초과가 발생한다. 즉 중간 과정에서 최적화가 이루어져야만한다.

---

이 문제를 dp를 이용해 중간 과정에서 최적화를 한다고 생각하면 여러 문제가 발생한다.

1. 로봇이 특정 위치에 도달할 때의 최솟값으로는 최적화 할 수 없다.

이 문제는 로봇이 좌, 우로 이동하며, 어떤순서로 도착하느냐에 따라 특정 위치에 도달하는 비용이 달라진다.

이 때, 특정 위치에 도달하는 값이 더 작은 분기라도, 최종적으로 전체 비용이 최소가 될 것을 보장하지는 않는다.

2. 그렇다면 특정 구간에 대한 최적화는 어떨까?

`dp[i][j]`라는 인덱스가 로봇이 `i`부터 `j` 까지의 모든 가로등을 탐색했을 때의 최소 비용을 나타낸다고 가정해보는 것이다.

로봇이 `i ~ j+1` 이라는 구간을 탐색하려면 필연적으로 `i~j`까지의 구간을 탐색해야 한다. 이제야 점화식의 인과관계가 보이는 것 같다.

점화식은 이러한 꼴이 될 것이다. `dp[i][j+i] = dp[i][j] + (이동할 때 발생한 비용).`

3. 그런데 또다른 문제가 있다. 이전 로봇의 위치를 알아야만 한다.

`i~j` 구간 값을 이용해 `i~j+1` 구간의 값을 구한다고 생각해보자.

`dp[i][j]`의 값에 이동 시 발생한 비용을 더해주어야 `dp[i][j+1]` 값을 구할 수 있다.

그런데 이 값은 로봇의 이동 거리에 따라 달라지며, `dp[i][j]`의 값이 마지막에 i를 추가해서 발생한 값인지 j를 추가해서 발생한 값인지,
즉 양 끝 중 로봇의 마지막 위치에 따라 이동 거리가 달라진다.

4. 따라서 dp를 다음 단계로 진행시킬 때 다음과 같은 네 가지의 경우의 수가 생긴다.
    
    - `i~j` 에서 우측으로 한 칸 이동해 `i ~ j+1`, 구간이 됨.
      - 이전 로봇 위치는 i 였음.
      - 이전 로봇 위치는 j 였음.
    - `i~j` 에서 좌즉으로 한 칸 이동해 `i-1 ~ j` 구간이 됨.
      - 이전 로봇 위치는 i 였음.
      - 이전 로봇 위치는 j 였음.
---

나는 이를 해결하기 위해 `dp[from][to]` 로 정의하고, 이중 두 번쨰 값인 to가 마지막에 로봇이 도착한 위치로 정의하였다.

즉 `dp[1][5]` 와 `dp[5][1]` 은 모두 `1~5` 구간을 탐색했을 때의 비용 최소값을 보장하지만,

`dp[1][5]`는 마지막에 로봇의 위치가 5인 경우, `dp[5][1]`은 마지막에 로봇의 위치가 1인 경우를 나타낸다.

이후 `dp[m][m]` 부터 방문할 구간의 범위를 점차 늘리면서 dp를 갱신해 나간다. 갱신에는 누적합 배열을 이용한 비용 산정과 같은 자잘한 내용이
포함되어 있지만 자세한 설명은 생략한다.

모든 dp가 완료되면. 답은 `Math.min(dp[0][n-1], dp[n-1][0])`이 된다.

다른 풀이를 보면 `dp[i][j][flag]` 와 같이 하나의 차원을 추가해 로봇의 위치를 특정하는 방법을 사용했는데,

이 방법은 기본적으로 `dp[i][j]` 와 `dp[j][i]`의 의미를 동일시 하기 때문에 본질적으로 내 방법과 큰 차이가 없으며,
오히려 내 방법이 메모리를 좀 더 절약했다고 볼 수 있다. 실제로 다른 자바 풀이에 비해 내가 메모리 소모가 가장 적다.
