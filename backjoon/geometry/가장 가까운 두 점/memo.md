### [가장 가까운 두 점](https://www.acmicpc.net/problem/2261)

---

문제는 간단하지만 풀이는 상당히 어려웠던 문제. 풀이에 도움을 많이 받았다.

간단하게 모든 점 사이의 거리를 구한다고 생각하면 O(N^2)의 복잡도를 지니게 되므로 어떻게든 이를 줄여야만 한다.

이 문제는 크게 분할 정복 방식 혹은 sweep line 방법으로 풀 수 있다. 둘 중 어떤 방식을 사용하든 x 범위와 y 범위에 대해 각각의 최적화가 꼭 필요하다.

---

분할 정복 방식부터 살펴보면, 전체 점 Point 구간을 절반씩 나누어 양쪽의 최소값을 병합해가며 최소값을 구하면 되겠다. 그러나 고려해야 할 점이 많다.

먼저 분할을 한다면 x, y 좌표에 대해서 적어도 한 좌표는 정렬되어 있는것이 유리하다. 한 좌표가 정렬되어 있다면 이웃한 Point 끼리 한 좌표에 대해서는 가까운 것이 보장되며, 해당 좌표에 대한 최적화를 꾀할 수 있다. 이 경우엔 x 좌표에 대해서 정렬했다.

다음은 Point 배열을 절반을 기준으로 분할해 나간다. 이 때 가장 작게 분할된 조각을 생각한다면, Point 사이의 거리는 적어도 두 개 이상이 있어야 산출이 가능하다. 때문에 Point를 한 개만 남기는 경우를 제하기 위해 3개 이하로 Point가 남는 경우 완전탐색으로 각 Point 간의 최소 거리를 구한다.
Point가 한 개만 남을 경우 `Integer.MAX_VALUE` 값을 반환해도 무방하다.

이제 바로 그 위 조각을 생각해보자. 그 위 조각은 중앙을 기준으로 각각 좌측, 우측 구간 점들의 최소거리 `min`을 알고있다.
그러나 이 최소거리가 무슨 의미가 있는가? 구간의 최소거리를 알기 위해선 결국 구간 내 모든 점들의 거리를 비교해야만 한다. 그 말인 즉 좌측과 우측의 개별 점들의 거리 역시 비교해야만 최소거리를 알 수 있다는 뜻이다. 이는 완전탐색과 다를것이 없다.

어쨌든 좌, 우 구간의 점들을 서로 비교하기는 해야한다. 그런데 좌 우 점들 중 가장 왼쪽 끝 점과 오른쪽 끝 점을 비교 할 필요가 있을까? 이 점들의 x값은 너무 멀어서 절대로 좌, 우 구간에서 구한 최소거리보다 짧을 수 없다.

따라서 이 최소거리를 최적화에 활용한다. 어떤 Point가 중앙이 되는 Point를 기준으로 x값이 `min`보다 멀다면, 이 점은 절대 반대쪽 점과의 거리가 최소가 될 수 없다. 구해야 할 것은 중앙을 기준으로 양 측에 x 거리가 `min`보다 작은 점이며, 이 점들끼리 다시 최소거리를 구해 `min`을 갱신한다.

다시 최소거리를 구할 때도 완전탐색을 해야 하지만 `min`값을 이용해 또다시 최적화를 할 수 있다. 후보가 되는 Point들을 별도로 저장해 y값으로 다시 정렬한 후 순차적으로 비교하며, y값이 `min` 보다 크다면 그 이상 비교하지 않고 다음 Point로 넘어간다.

이러한 최적화 동작들은 `min`값이 점점 더 작아질 것이기 때문에 계속 효율적이 되어간다.

---

sweep line 방식은 더 간단하지만 java의 경우 특수한 자료구조가 필요하다. 우선 똑같이 x에 대해 정렬하고, 첫 두 Point 사이의 거리를 `min`값으로 초기화한다.

이후 2번 째 Point부터 이전 Point와 비교하며 `min`을 갱신한다. 이 때, 항상 좌측 끝 점부터 비교할 필요는 없다. 비교할 기준 Point가 계속해서 우측으로 옮겨가기 때문에 어떤 비교대상 Point의 x 거리가 `min`값보다 커진다면 그 점은 이후부터는 비교할 필요가 없다. 이를 위해 비교가 가능한 가장 좌측 점의 index를 `low`에 저장하고 이를 갱신한다.

이전 Point와 비교할 때 x값에 대해서는 최적화가 완료되었다. 그러나 동일하게 y값에 대해서도 최적화하지 않으면 시간내에 문제를 해결할 수 없다. y값에 대해서도 y 거리가 `min`보다 크다면 이 점은 비교할 필요가 없다.

그러나 분할 정복 방식처럼 해당하는 x조건을 만족하는 점들에 대해 따로 저장하고 다시 y에 대해 정렬하는 것은 비효율적이다. 분할 정복때는 병합이 일어나는 지점에서만 해당 동작을 수행했었다. 그러나 이 방식은 index 2 이후로 모든 지점에서 해당 동작이 수행된다.

여기서 필요한 것이 `TreeSet`이다. TreeSet은 이진 탐색 트리로 구현된 자료구조로, Set처럼 중복을 제거하고 저장 순서가 보장되지 않지만, 내부 자료를 정렬해 저장한다는 특징이 있다.

상술한 low 인덱스와 x기준에 따라 TreeSet에 후보군을 저장하고, 삭제한다. 그러나 이 TreeSet의 정렬은 y값을 기준으로 한다.

따라서 비교할 mainPoint마다 TreeSet 내에서 비교가 가능한 y 구간을 구할 수 있다. 이는 `TreeSet.subSet()`으로 쉽게 구현할 수 있으며 이는 내부적으로 이진탐색을 사용한다.

결과적으로 비교하는 mainPoint마다 x, y 거리가 모두 `min`값 이내인 Point들만 비교하는 것이 가능하다. 이 역시도 `min`값이 계속해서 작아지기 때문에 점점 효율적이 되어간다.

추가적으로 TreeSet을 위한 Comparator를 작성할 때, y값이 아니라 2차적으로 x값에 대해서도 정렬해주어야 한다. 만약 x값에 대한 조건을 넣지 않으면 y가 같고 x가 다른 두 Point에 대해 같은 객체로 인식하고 값의 추가가 제대로 이루어지지 않는다.
