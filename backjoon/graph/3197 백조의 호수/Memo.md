[백조의 호수](https://www.acmicpc.net/problem/3197)

---

이 문제는 두 종류의 bfs가 필요하다. 하나는 백조가 다른 백조를 찾아 이동하는 bfs, 다른 하나는 시간이 지남에 따라 얼음이 녹는 bfs이다.

그렇다면 해결의 흐름은 간단하다. 백조 bfs로 백조를 찾을 수 있는지 확인하고, 찾을 수 없다면 얼음이 녹는 bfs를 한 번 수행하고 반복한다.

정석적인 풀이로는 각각의 bfs를 매번 처음실행하는것이 시간 초과를 일으키므로, 이전 bfs의 결과를 이용해 중간지점부터 수행하는 풀이가 있다.

특히 얼음이 녹는 bfs의 경우, 이전 단계에서 녹았던 얼음의 다음 위치가 녹기 시작하므로 매번 처음부터 bfs를 실행할 필요가 없다.

---

나는 문제를 풀다가 좀 더 직관적인 것 같은 아이디어가 떠올라 그렇게 풀었다.

먼저 intMap 이라는 2차원 배열을 만든다. 이 배열은 각 위치의 얼음이 녹기까지 얼마의 시간이걸리는지를 저장한다. (얼음이 없는 위치는 0이다.) 

intMap을 채우기 위해서 얼음의 테두리에서부터 bfs를 시작한다. bfs는 얼음 타일을 찾아 intMap의 해당 위치의 값보다 작은 경우 갱신하며, 한번 갱신될 때 마다 값이 1 증가한다.

예를 들어 다음과 같은 입력은 이러한 intMap을 형성한다.

    L.              00
    XX              11
    XX              22
    XX      ->      33
    XX              22
    XX              11
    .L              00

intMap의 형태는 이렇게 마치 특정 위치의 비용을 나타내는 형태로 변한다. map 의 해당 위치를 밟기 위해선 intMap의 해당 위치 만큼의 시간이 지나야 한다.

그렇다면 문제는 결국 intMap 의 비용정보를 이용해 L 부터 L 까지의 최소 비용 경로 문제로 변한다. 이러한 문제는 PriorityQueue로 쉽게 풀 수 있다.

전체 문제는 별도의 반복 없이 두 번의 bfs로 풀이된다. 시간 경과는 엇비슷하지만 좀 더 직관적이다.

