[매출 하락 최소화](https://school.programmers.co.kr/learn/courses/30/lessons/72416)

---

문제에 접근하는 방법을 생각하기 굉장히 어려운 문제.

각 인원은 회의에 참석하거나 참석하지 않을 수 있고, 팀장-팀원 사이의 1단계 서브노드 내에서 한 명은 꼭 회의에 참석하여야만 한다.

위 조건을 만족하는 경우 중 가장 비용이 작은 경우를 찾아야 하므로 이 문제는 dp를 이용한 최소비용 문제로 풀어볼 수 있겠다.

이 문제는 명백히 루트 노드가 존재하므로 루트 노드를 기준으로 dp를 푼다고 할 때, 리프 노드부터 루트 노드까지 역으로 순회해 최종적으로 루트 노드의 비용이 최소가 되게 하면 될 것 같다. 그렇다면 dp의 각 위치의 값은 해당 가지의 리프노드부터 해당 노드까지의 비용 합산의 최솟값이 된다.

그런데 노드의 상태는 참석하거나 참석하지 않거나 둘 중 하나인데, 이 상태는 부모-자식의 상태에도 영향을 끼친다. 따라서 그냥 최솟값만을 저장하며 dp를 진행하기엔 무리가 있다.

따라서 dp의 차원을 하나 늘려, 모든 노드에 대해 해당 노드가 참석하는 경우, 참석하지 않는 경우의 최소비용을 저장한다.

리프노드는 아주 간단하다. 리프노드는 자기 자신이 참석하면 자신의 값, 참석하지 않으면 0이다.

그 위 노드부터는 자식들의 값을 모두 합산한 후 자신이 참석하는 경우와 참석하지 않는 경우를 나눈다. 이 때 자식들이 참석하거나 참석하지 않는 경우 중 더 작은값을 합산하며, 해당 값은 `minChildSaleSum` 이다.

자신이 참석하는 경우는 어찌되든 조건을 만족하므로 자식들이 어떤 값을 더했던 `minChildSaleSum`와 자기 자신의 값을 더하면 된다.

자신이 참석하지 않는 경우는 자식들 중 적어도 하나는 참석해야만 한다. 이 여부는 각각의 자식들이 참석한 경우와 참석하지 않는 경우의 값의 차이의 최소값 `minSaleDiff`를 구하여 알 수 있다.

만약 어떤 자식이 참석하는 경우가 참석하지 않는 경우보다 값이 같거나 작다면, 가능한 한 참석하는 쪽이 유리하기 때문에 해당 자식은 참석했을 것이다. 따라서 모든 자식이 참석하지 않는 쪽이 값이 더 작았다면 `minSaleDiff` 는 양수가 되고, 하나의 자식이라도 참석했다면 `minSaleDiff` 는 0혹은 음수가 된다.

따라서 `minSaleDiff`와 0 중 더 큰 값을 `minChildSaleSum`에 더해주면 자식들이 아무도 참석하지 않았을 때 비용차이가 제일 작은 자식이 하나만이 참석하도록 바꾼 비용을 구할 수 있다. 해당 값을 본인이 참석하지 않은 경우에 저장하면 된다.

모든 노드의 순회가 끝나면 dp[1][0], dp[1][1]에 마지막으로 1번 노드까지의 최소 비용이 저장되어 있을 것이다. 이 두 값중 작은 값을 반환하면 답을 구할 수 있다.
